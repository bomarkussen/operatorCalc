{
    "contents" : "# ------------------\n# Class definition\n# ------------------\n\noperator <- setClass(\"operator\", slots=c(alpha=\"matFct\",beta=\"matFct\",gamma=\"matFct\",delta=\"matFct\",epsilon=\"matFct\"))\n\nsetValidity(\"operator\", function(object) {\n  msg <- NULL\n  valid <- TRUE\n  if (length(unique(c(object@alpha@mesh[1],\n                      object@beta@mesh[1],\n                      object@gamma@mesh[1],\n                      object@delta@mesh[1],\n                      object@epsilon@mesh[1])))!=1) {\n    valid <- FALSE\n    msg <- c(msg,\"Left endpoints of the domains of the coefficient functions must coinside\")\n  }\n  if (length(unique(c(object@alpha@mesh[length(object@alpha@mesh)],\n                      object@beta@mesh[length(object@beta@mesh)],\n                      object@gamma@mesh[length(object@gamma@mesh)],\n                      object@delta@mesh[length(object@delta@mesh)],\n                      object@epsilon@mesh[length(object@epsilon@mesh)])))!=1) {\n    valid <- FALSE\n    msg <- c(msg,\"Right endpoints of the domains of the coefficient functions must coinside\")\n  }\n  if (dim(object@alpha@f)[1]!=dim(object@alpha@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"Value and domain dimension of the multiplication operator must coinside\")\n  }\n  if (dim(object@beta@f)[1]!=dim(object@alpha@f)[1]) {\n    valid <- FALSE\n    msg <- c(msg,\"Triangular and multiplication operators must have the same value dimension\")\n  }\n  if (dim(object@gamma@f)[1]!=dim(object@alpha@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"Triangular and multiplication operators must have the same domain dimension\")\n  }\n  if (dim(object@beta@f)[2]!=dim(object@gamma@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"K dimension for value and domain of the triangular operator must coinside\")\n  }\n  if (dim(object@delta@f)[1]!=dim(object@alpha@f)[1]) {\n    valid <- FALSE\n    msg <- c(msg,\"Projection and multiplication operators must have the same value dimension\")\n  }\n  if (dim(object@epsilon@f)[1]!=dim(object@alpha@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"Projection and multiplication operators must have the same domain dimension\")\n  }\n  if (dim(object@delta@f)[2]!=dim(object@epsilon@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"L dimension for value and domain of the projection operator must coinside\")\n  }\n  if (valid) TRUE else msg\n})\n\n# ---------\n# Methods\n# ---------\n\nsetMethod(\"show\",\n          signature=\"operator\",\n          definition=function(object) {\n            cat(\"An object of class \",class(object),\"\\n\",sep=\"\")\n            cat(\" Lattice operator on the space of functions: [\",object@alpha@mesh[1],\",\",\n                object@alpha@mesh[length(object@alpha@mesh)],\"] -> \",\n                dim(object@alpha@f)[1],\"-dimensional space\\n\",sep=\"\")\n            cat(\" Number of triangular and projection components = (\",dim(object@beta@f)[2],\n                \",\",dim(object@delta@f)[2],\")\\n\",sep=\"\")\n            invisible(NULL)\n          })\n\nsetMethod(\"superSample\",\n          signature=c(x=\"numeric\",e1=\"operator\"),\n          definition=function(x,e1) {\n            operator(alpha=superSample(x,e1@alpha),\n                     beta=superSample(x,e1@beta),\n                     gamma=superSample(x,e1@gamma),\n                     delta=superSample(x,e1@delta),\n                     epsilon=superSample(x,e1@epsilon))\n          })\n\nsetMethod(\"[\",\n          signature=c(x=\"operator\",i=\"numeric\"),\n          definition=function(x,i) {\n            k <- dim(x@beta@f)[2];  k <- min(1,k):k\n            l <- dim(x@delta@f)[2]; l <- min(1,l):l\n            operator(alpha=x@alpha[i,i],beta=x@beta[i,k],gamma=x@gamma[i,k],delta=x@delta[i,l],epsilon=x@epsilon[i,l])\n          })\n\nsetMethod(\"-\",\n          signature=c(e1=\"operator\"),\n          definition=function(e1) {\n            operator(alpha=-e1@alpha,\n                     beta=-e1@beta,\n                     gamma=e1@gamma,\n                     delta=-e1@delta,\n                     epsilon=e1@epsilon)\n          })\n\nsetMethod(\"+\",\n          signature=c(e1=\"operator\",e2=\"operator\"),\n          definition=function(e1,e2) {\n            operator(alpha=e1@alpha+e2@alpha,\n                     beta=e1@beta|e2@beta,\n                     gamma=e1@gamma|e2@gamma,\n                     delta=e1@delta|e2@delta,\n                     epsilon=e1@epsilon|e2@epsilon)\n          })\n\nsetMethod(\"-\",\n          signature=c(e1=\"operator\",e2=\"operator\"),\n          definition=function(e1,e2) {\n            operator(alpha=e1@alpha-e2@alpha,\n                     beta=e1@beta|-e2@beta,\n                     gamma=e1@gamma|e2@gamma,\n                     delta=e1@delta|-e2@delta,\n                     epsilon=e1@epsilon|e2@epsilon)\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"operator\",e2=\"operator\"),\n          definition=function(e1,e2) {\n            operator(alpha=e1@alpha*e2@alpha,\n                     beta=e1@beta|e1@alpha*e2@beta-e1@beta*backward(transpose(e1@gamma)*e2@beta),\n                     gamma=transpose(e2@alpha)*e1@gamma+e2@gamma*backward(transpose(e2@beta)*e1@gamma)|e2@gamma,\n                     delta=e1@delta|e1@alpha*e2@delta+e1@beta*forward(transpose(e1@gamma)*e2@delta),\n                     epsilon=transpose(e2@alpha)*e1@epsilon+e2@gamma*backward(transpose(e2@beta)*e1@epsilon)+e2@epsilon*integral(transpose(e2@delta)*e1@epsilon)|e2@epsilon)\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"operator\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            e1@alpha*e2+e1@beta*forward(transpose(e1@gamma)*e2)+e1@delta*integral(transpose(e1@epsilon)*e2)\n          })\n\nsetMethod(\"inverse\",\n          signature=c(e1=\"operator\"),\n          # update of old implementation: so far the best! worst error 1e-6\n          # but should be improved on accuracy and speed!\n          definition=function(e1) {\n            # take dimensions\n            p <- length(e1@alpha@mesh)\n            N <- dim(e1@alpha@f)[1]\n            K <- dim(e1@beta@f)[2]\n            L <- dim(e1@delta@f)[2]\n            \n            # Take properties from matFct object and global options: c++ needs order > 1\n            order <- max(2,max(options()$\"minimal.polynomial.order\",min(options()$\"maximal.polynomial.order\",dim(e1@alpha@g)[4])))\n            super <- 2*order+1\n            \n            # super sampling according to order of polynomial interpolation\n            t.obs <- as.numeric(e1@alpha@mesh)\n            t.super <- cumsum(c(t.obs[1],rep(diff(t.obs)/(super+1),each=super+1)))\n            \n            # ODE for triangular part\n            if (K>0) {\n              # coefficient function for ODE\n              dy <- function(tt,state,parms) {\n                with(as.list(parms),{list(c(matrix(evaluate(tt,aa),K,N)%*%\n                                              base::solve(matrix(evaluate(tt,bb),N,N),\n                                                          matrix(evaluate(tt,cc),N,K))%*%\n                                              matrix(state,K,K)))})\n              }\n              # solve ODE for kappa.transpose\n              parms <- list(N=N,K=K,aa=-transpose(e1@gamma),bb=e1@alpha,cc=e1@beta)\n              kappa.transpose <- aperm(array(deSolve::ode(y=c(diag(K)),times=t.super,func=dy,parms=parms,rtol=1e-10,atol=1e-10)[,-1],\n                                             dim=c(length(t.super),K,K)),c(2,3,1))\n            }\n            \n            # solve multiplication part\n            inv.alpha <- inverse(e1@alpha)\n            \n            # solve triangular part\n            if (K==0) {\n              inv.beta  <- e1@beta\n              inv.gamma <- e1@gamma\n            } else {\n              # approximate tilde(beta)\n              res <- .Call('operatorCalc_inv_beta', PACKAGE = 'operatorCalc', e1@alpha@f, e1@alpha@g, e1@beta@f, e1@beta@g, \n                           kappa.transpose, order, super, e1@alpha@continuous&e1@beta@continuous)\n              attr(res$g,\"dim\") <- c(N,K,order,p-1)\n              inv.beta <- matFct(mesh=e1@alpha@mesh,f=res$f,g=aperm(res$g,c(1,2,4,3)),continuous=e1@alpha@continuous&e1@beta@continuous)\n              # approximate tilde(gamma)\n              res <- .Call('operatorCalc_inv_gamma', PACKAGE = 'operatorCalc', e1@alpha@f, e1@alpha@g, e1@gamma@f, e1@gamma@g, \n                           kappa.transpose, order, super, e1@alpha@continuous&e1@gamma@continuous)\n              attr(res$g,\"dim\") <- c(N,K,order,p-1)\n              inv.gamma <- matFct(mesh=e1@alpha@mesh,f=res$f,g=aperm(res$g,c(1,2,4,3)),continuous=e1@alpha@continuous&e1@gamma@continuous)\n            }\n            \n            # solve projection part\n            if (L==0) {\n              inv.epsilon <- e1@epsilon\n              inv.delta   <- e1@delta\n            } else {\n              if (K==0) {\n                inv.epsilon <- inverse(transpose(e1@alpha),e1@epsilon)\n                inv.delta   <- -inverse(e1@alpha,e1@delta)%*%base::solve(diag(L)+integral(transpose(inv.epsilon)*e1@delta))\n              } else {\n                inv.epsilon <- inverse(transpose(e1@alpha),e1@epsilon)+inv.gamma*backward(transpose(inv.beta)*e1@epsilon)\n                inv.delta   <- -(inverse(e1@alpha,e1@delta)+inv.beta*forward(transpose(inv.gamma)*e1@delta))*\n                  base::solve(diag(L)+integral(transpose(inv.epsilon)*e1@delta))                \n              }\n            }\n            \n            # return result\n            operator(alpha=inv.alpha,beta=inv.beta,gamma=inv.gamma,delta=inv.delta,epsilon=inv.epsilon)\n          })\n",
    "created" : 1408957269562.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "24134615",
    "id" : "24DD5227",
    "lastKnownWriteTime" : 1410512184,
    "path" : "C:/Users/pdq668/Dropbox/Full-rank functional regression/operatorCalc/R/operator.R",
    "project_path" : "R/operator.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}