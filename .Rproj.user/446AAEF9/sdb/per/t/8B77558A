{
    "contents" : "operator.MLE <- function(matData,components=2,lambda.max=0.1,step.factor=3/2,gamma.min=0,gamma.max=0.1,verbose=TRUE) {\n  # matData: (n,p,N)-array with data points.\n  # assume equidistant sampling on [0,1], i.e. t_j = (j-1)/(p-1) for j=1,...,p\n  \n  # simulate data for test: TO BE REMOVED LATER!!!\n  n <- 100\n  p <- 10\n  N <- 2\n  matData <- aperm(apply(array(rnorm(n*p*N)/sqrt(p),dim=c(n,p,N)),c(1,3),cumsum),c(2,1,3))+\n    rnorm(n*p*N)*1\n  matplot(t(matData[,,1]),type=\"l\")\n  components <- 2\n  \n  # take dimensions\n  n <- dim(matData)[1]\n  p <- dim(matData)[2]\n  N <- dim(matData)[3]\n  \n  # embed data\n  X <- approximate(seq(0,1,length.out=p),aperm(matData,c(2,3,1)))\n  #plot(transpose(tilde.X))\n  \n  # remove mean structure and make singular value decomposition\n  my.svd <- svd(matrix(matData-rep(apply(matData,c(2,3),mean),each=n),n,p*N),0,components)\n  my.data <- array(my.svd$v%*%diag(my.svd$d[1:components],rep(components,2)),\n                   dim=c(p,N,components))\n  delta1 <- approximate(seq(0,1,length.out=p),my.data*sqrt(p/n))\n  alpha1 <- approximate(seq(0,1,length.out=p),\n                       aperm(array(apply(matData,2,cov),dim=c(N,N,p)),c(3,1,2))\n                       )-(1/p)*delta1*transpose(delta1)\n  epsilon1 <- delta1\n  \n  alpha2 <- inverse(alpha1)\n  delta2 <- -inverse(alpha1,delta1)*solve(diag(dim(delta1@f)[2])+integral(transpose(epsilon1)*inverse(alpha1,delta1)))\n  epsilon2 <- inverse(transpose(alpha1),epsilon1)\n  delta12   <- alpha1*delta2 + epsilon1*forward(transpose(delta1)*delta2) -\n    delta1*forward(transpose(epsilon1)*delta2)\n  epsilon12 <- transpose(alpha2)*epsilon1 + delta2*backward(transpose(epsilon2)*epsilon1) + \n    epsilon2*forward(transpose(delta2)*epsilon1)\n  \n  #####################################\n  \n  plot(alpha1)\n  plot(delta1)\n  plot(delta1*transpose(epsilon1))\n  plot(delta1*transpose(epsilon12)+delta12*transpose(epsilon2))\n  \n  # true values\n  #alpha <- approximate(seq(0,1,length.out=p),aperm(array(c(1,0,0,1),dim=c(N,N,p)),c(3,1,2)))\n  #epsilon <- approximate(seq(0,1,length.out=p),aperm(array(c(1,0,0,1),dim=c(N,N,p)),c(3,1,2)))\n  #delta   <- approximate(seq(0,1,length.out=p),array(c(seq(0,1,length.out=p),seq(0,0,length.out=p),\n  #                                                     seq(0,0,length.out=p),seq(0,1,length.out=p)),dim=c(p,N,N)))\n  #summary(t(apply(evaluate(seq(0,1,0.01),alpha),3,function(x) eigen(x)$values)))\n\n  neg.gradient <- function(x) {\n    # assume variables: n, X, S, h (list with elements alpha, delta, epsilon)\n    tmpS <- S\n    if (x!=0) {\n      tmpS@alpha@f   <- S@alpha@f+x*h$alpha\n      tmpS@delta@f   <- S@delta@f+x*h$delta\n      tmpS@epsilon@f <- S@epsilon@f+x*h$epsilon\n    }\n    invS <- inverse(tmpS)\n    return(list(alpha=0*triangular(p*invS@alpha+(1/2)*(invS@delta*transpose(invS@epsilon)+invS@epsilon*transpose(invS@delta))-(p/n)*X*transpose(X)),\n                delta=triangular(invS@alpha*tmpS@epsilon+2*invS@delta*backward(transpose(invS@epsilon)*tmpS@epsilon)-(2*p/n)*X*backward(transpose(X)*tmpS@epsilon)),\n                epsilon=triangular(invS@alpha*tmpS@delta+2*invS@epsilon*forward(transpose(invS@delta)*tmpS@delta)-(2*p/n)*X*forward(transpose(X)*tmpS@delta))\n    ))\n  }\n  \n  S <- inverse(as.operator(symmOperator(alpha=alpha,delta=(sqrt(p))*delta,epsilon=(sqrt(p))*epsilon)))\n  \n  lambda.start <- 1/(3*N*p*components)\n  lambda.max <- 1e-4\n  \n  maxIter <- 100\n  alphaConv <- matrix(0,maxIter,5)\n  deltaConv <- matrix(0,maxIter,5)\n  epsilonConv <- matrix(0,maxIter,5)\n  \n  g <- neg.gradient(0)\n  h <- g\n  #lambda <- lambda.start\n  for (iter in 1:maxIter) {\n    lambda <- lambda.max\n#    for (up.steps in 0:2) {\n#      g.new <- neg.gradient(lambda)\n#      if (sum(g.new$alpha*h$alpha) +\n#          sum(g.new$delta*h$delta) +\n#          sum(g.new$epsilon*h$epsilon) < 0) break\n#      lambda <- lambda*step.factor\n#    }\n    for (down.steps in 0:9) {\n#      lambda <- lambda*(step.factor+1)/(2*step.factor)\n      g.new <- neg.gradient(lambda)\n      if (sum(g.new$alpha*h$alpha) +\n          sum(g.new$delta*h$delta) +\n          sum(g.new$epsilon*h$epsilon) >= 0) break\n      lambda <- lambda/step.factor\n    }\n    \n    # update coefficients\n    S@alpha@f   <- S@alpha@f   + lambda*h$alpha\n    S@delta@f   <- S@delta@f   + lambda*h$delta\n    S@epsilon@f <- S@epsilon@f + lambda*h$epsilon\n    \n    # conjugate gradients\n    gamma <- (sum((g.new$alpha-g$alpha)*g.new$alpha) +\n              sum((g.new$delta-g$delta)*g.new$delta) +\n              sum((g.new$epsilon-g$epsilon)*g.new$epsilon)) /\n             (sum(g$alpha*g$alpha)+sum(g$delta*g$delta)+sum(g$epsilon*g$epsilon))\n    gamma <- min(gamma.max,max(gamma.min,gamma))\n    h$alpha   <- g.new$alpha   + gamma*h$alpha\n    h$delta   <- g.new$delta   + gamma*h$delta\n    h$epsilon <- g.new$epsilon + gamma*h$epsilon\n    g <- g.new\n    \n    # stepest descent\n    #    h <- g.new\n\n    # delta and epsilon of same size: rescale\n    #delta.vs.epsilon <- sqrt(sqrt(sum(S@delta@f^2)/sum(S@epsilon@f^2)))\n#    delta.vs.epsilon <- sqrt(sqrt(sum(g$delta^2)/sum(g$epsilon^2)))\n#    S@delta@f   <- S@delta@f   / delta.vs.epsilon\n#    S@epsilon@f <- S@epsilon@f * delta.vs.epsilon\n#    h$delta     <- h$delta     / delta.vs.epsilon\n#    h$epsilon   <- h$epsilon   * delta.vs.epsilon\n#    g$delta     <- g$delta     / delta.vs.epsilon\n#    g$epsilon   <- g$epsilon   * delta.vs.epsilon\n    \n#    invS <- inverse(S)\n#    dAlpha <- triangular(-n*1*invS@alpha-n/2*(invS@delta*transpose(invS@epsilon)+invS@epsilon*transpose(invS@delta))+1*X*transpose(X))\n#    dDelta <- triangular(-n*invS@alpha*S@epsilon-2*n*invS@delta*backward(transpose(invS@epsilon)*S@epsilon)+2*1*X*backward(transpose(X)*S@epsilon))\n#    dEpsilon <- triangular(-n*invS@alpha*S@delta-2*n*invS@epsilon*forward(transpose(invS@delta)*S@delta)+2*1*X*forward(transpose(X)*S@delta))\n\n    # diagnostics\n    if (verbose) {\n      cat(\"iteration\",iter,\": steps down=\",down.steps,\": lambda=\",lambda,\", conjugate gamma=\",gamma,\"\\n\")\n      delta.vs.epsilon <- sqrt(sqrt(sum(g$delta^2)/sum(g$epsilon^2)))\n      tmp <- rbind(quantile(g$alpha),quantile(h$alpha),\n                   quantile(g$delta / delta.vs.epsilon),quantile(h$delta / delta.vs.epsilon),\n                   quantile(g$epsilon * delta.vs.epsilon),quantile(h$epsilon * delta.vs.epsilon))\n      rownames(tmp) <- c(\"g.alpha\",\"h.alpha\",\"g.delta\",\"h.delta\",\"g.epsilon\",\"h.epsilon\")\n      if (gamma!=0) print(tmp) else print(tmp[c(1,3,5),])\n      alphaConv[iter,] <- quantile(g$alpha)\n      deltaConv[iter,] <- quantile(g$delta / delta.vs.epsilon)\n      epsilonConv[iter,] <- quantile(g$epsilon * delta.vs.epsilon)\n    }\n  }\n\n  # convergence diagnostics\n  if (verbose) {\n    par(mfrow=c(1,1))\n    matplot(alphaConv[,],type=\"b\",xlab=\"iteration\",ylab=\"5-point statistics of gradient\",main=\"convergence statistics for alpha\")\n    matplot(deltaConv[,],type=\"b\",xlab=\"iteration\",ylab=\"5-point statistics of gradient\",main=\"convergence statistics for delta\")\n    matplot(epsilonConv[,],type=\"b\",xlab=\"iteration\",ylab=\"5-point statistics of gradient\",main=\"convergence statistics for epsilon\")\n  }\n\n  # diagnostics\n  invS <- inverse(S)\n  plot(invS@alpha); title(\"inverse: alpha\")\n  plot(invS@delta*transpose(invS@epsilon)); title(\"inverse: delta*transpose(epsilon)\")\n  plot(approximate(seq(0,1,length.out=p),aperm(g$alpha,c(3,1,2)))); title(\"dAlpha\")\n  plot(approximate(seq(0,1,length.out=p),aperm(g$delta,c(3,1,2)))); title(\"dDelta\")\n  plot(approximate(seq(0,1,length.out=p),aperm(g$epsilon,c(3,1,2)))); title(\"dEpsilon\")\n\n  # image\n  im <- matrix(0,p,p)\n  for (x in 1:p) for (y in 1:p) {\n    im[x,y] <- (1/p)*(evaluate(max(x,y)/p,invS@epsilon)[,,1] %*% evaluate(min(x,y)/p,transpose(invS@delta))[,,1])[1,1]-\n      cov(matData[,x,1],matData[,y,1])+(x==y)\n  }\n  im.start <- matrix(0,p,p)\n  for (x in 1:p) for (y in 1:p) {\n    im.start[x,y] <- (evaluate(x/p,delta)[,,1] %*% evaluate(y/p,transpose(delta))[,,1])[1,1]-\n      cov(matData[,x,1],matData[,y,1])+(x==y)\n  }\n\n  image(im,main=\"lattice misfit\")\n  summary(c(im))\n  image(im.start,main=\"pca misfit\")\n  summary(c(im.start))\n  par(mfrow=c(1,1))\n  plot(sort(c(im.start)),sort(c(im)))\n  abline(0,1)\n}",
    "created" : 1422273094976.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3269585455",
    "id" : "8B77558A",
    "lastKnownWriteTime" : 1410788791,
    "path" : "C:/Users/pdq668/Dropbox/Full-rank functional regression/operatorCalc/R/operatorMLE.R",
    "project_path" : "R/operatorMLE.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}