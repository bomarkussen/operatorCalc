{
    "contents" : "# ------------------\n# Class definition\n# ------------------\n\nsymmOperator <- setClass(\"symmOperator\", slots=c(alpha=\"matFct\",delta=\"matFct\",epsilon=\"matFct\"))\n\nsetValidity(\"symmOperator\", function(object) {\n  msg <- NULL\n  valid <- TRUE\n  if (length(unique(c(object@alpha@mesh[1],\n                      object@delta@mesh[1],\n                      object@epsilon@mesh[1])))!=1) {\n    valid <- FALSE\n    msg <- c(msg,\"Left endpoints of the domains of the coefficient functions must coinside\")\n  }\n  if (length(unique(c(object@alpha@mesh[length(object@alpha@mesh)],\n                      object@delta@mesh[length(object@delta@mesh)],\n                      object@epsilon@mesh[length(object@epsilon@mesh)])))!=1) {\n    valid <- FALSE\n    msg <- c(msg,\"Right endpoints of the domains of the coefficient functions must coinside\")\n  }\n  if (dim(object@alpha@f)[1]!=dim(object@alpha@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"Value and domain dimension of the multiplication operator must coinside\")\n  }\n  if (dim(object@delta@f)[1]!=dim(object@alpha@f)[1]) {\n    valid <- FALSE\n    msg <- c(msg,\"Projection and multiplication operators must have the same value dimension\")\n  }\n  if (dim(object@epsilon@f)[1]!=dim(object@alpha@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"Projection and multiplication operators must have the same domain dimension\")\n  }\n  if (dim(object@delta@f)[2]!=dim(object@epsilon@f)[2]) {\n    valid <- FALSE\n    msg <- c(msg,\"L dimension for value and domain of the projection operator must coinside\")\n  }\n  if (valid) TRUE else msg\n})\n\n# ---------\n# Methods\n# ---------\n\nsetMethod(\"show\",\n          signature=\"symmOperator\",\n          definition=function(object) {\n            cat(\"An object of class \",class(object),\"\\n\",sep=\"\")\n            cat(\" Symmetric lattice operator on the space of functions: [\",object@alpha@mesh[1],\",\",\n                object@alpha@mesh[length(object@alpha@mesh)],\"] -> \",\n                dim(object@alpha@f)[1],\"-dimensional space\\n\",sep=\"\")\n            cat(\" Number of components = \",dim(object@delta@f)[2],\"\\n\",sep=\"\")\n            invisible(NULL)\n          })\n\nsetMethod(\"superSample\",\n          signature=c(x=\"numeric\",e1=\"symmOperator\"),\n          definition=function(x,e1) {\n            symmOperator(alpha=superSample(x,e1@alpha),\n                         delta=superSample(x,e1@delta),\n                         epsilon=superSample(x,e1@epsilon))\n          })\n\nsetMethod(\"[\",\n          signature=c(x=\"symmOperator\",i=\"numeric\"),\n          definition=function(x,i) {\n            l <- dim(x@delta@f)[2]; l <- min(1,l):l\n            symmOperator(alpha=x@alpha[i,i],\n                         delta=x@delta[i,l],\n                         epsilon=x@epsilon[i,l])\n          })\n\nsetMethod(\"-\",\n          signature=c(e1=\"symmOperator\"),\n          definition=function(e1) {\n            symmOperator(alpha=-e1@alpha,\n                         delta=-e1@delta,\n                         epsilon=e1@epsilon)\n          })\n\nsetMethod(\"+\",\n          signature=c(e1=\"symmOperator\",e2=\"symmOperator\"),\n          definition=function(e1,e2) {\n            symmOperator(alpha=e1@alpha+e2@alpha,\n                         delta=e1@delta|e2@delta,\n                         epsilon=e1@epsilon|e2@epsilon)\n          })\n\nsetMethod(\"-\",\n          signature=c(e1=\"symmOperator\",e2=\"symmOperator\"),\n          definition=function(e1,e2) {\n            symmOperator(alpha=e1@alpha-e2@alpha,\n                         delta=e1@delta|-e2@delta,\n                         epsilon=e1@epsilon|e2@epsilon)\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"matrix\",e2=\"symmOperator\"),\n          definition=function(e1,e2) {\n            symmOperator(alpha=e1*e2@alpha,delta=e1*e2@delta,epsilon=e2@epsilon)\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"numeric\",e2=\"symmOperator\"),\n          definition=function(e1,e2) {\n            symmOperator(alpha=e1*e2@alpha,delta=(sign(e1)*sqrt(abs(e1)))*e2@delta,epsilon=sqrt(abs(e1))*e2@epsilon)\n          })\n\n# setMethod(\"inverse\",\n#           signature=c(e1=\"symmOperator\"),\n#           # Using symmetric structure it should be possible to improve\n#           # speed and numerical precision\n#           definition=function(e1) {\n#             tmp <- inverse(as.operator(e1))\n#             symmOperator(alpha=tmp@alpha,\n#                          delta=tmp@delta,\n#                          epsilon=tmp@epsilon)\n#           })\n\nsetMethod(\"inverse\",\n          signature=c(e1=\"symmOperator\"),\n          # Use numerical minimization of misfit energy\n          definition=function(e1) {\n            # Brownian motion\n            e1 <- symmOperator(\n              alpha=superSample(seq(0,1,0.01),matFct(mesh=mesh(c(0,1)),f=array(c(1,1),dim=c(1,1,2)),g=array(0,dim=c(1,1,1,0)),continuous=TRUE)),\n              delta=superSample(seq(0,1,0.01),matFct(mesh=mesh(c(0,1)),f=array(c(0,1),dim=c(1,1,2)),g=array(0,dim=c(1,1,1,0)),continuous=TRUE)),\n              epsilon=superSample(seq(0,1,0.01),matFct(mesh=mesh(c(0,1)),f=array(c(1,1),dim=c(1,1,2)),g=array(0,dim=c(1,1,1,0)),continuous=TRUE))\n            )\n\n            # make e1 piecewise linear\n            e1@alpha@g   <- array(0,dim=c(dim(e1@alpha@g)[1:3],0))\n            e1@delta@g   <- array(0,dim=c(dim(e1@delta@g)[1:3],0))\n            e1@epsilon@g <- array(0,dim=c(dim(e1@epsilon@g)[1:3],0))\n            \n            # make initial guess at inverse operator using only projection part\n            tmp <- solve(diag(dim(e1@delta@f)[2])+integral(transpose(e1@epsilon)*inverse(e1@alpha,e1@delta)))\n            alpha1    <- inverse(e1@alpha)\n            delta1    <- -inverse(e1@alpha,e1@delta)*tmp\n            epsilon1  <- inverse(transpose(e1@alpha),e1@epsilon)\n            delta12   <- inverse(e1@alpha,e1@delta) + epsilon1*forward(transpose(delta1)*e1@delta) -\n              delta1*forward(transpose(epsilon1)*e1@delta)\n            epsilon12 <- transpose(e1@alpha)*epsilon1 + e1@delta*backward(transpose(e1@epsilon)*epsilon1) + \n              e1@epsilon*forward(transpose(e1@delta)*epsilon1)\n            alpha1@g    <- array(0,dim=c(dim(alpha1@g)[1:3],0))\n            delta1@g    <- array(0,dim=c(dim(delta1@g)[1:3],0))\n            epsilon1@g  <- array(0,dim=c(dim(epsilon1@g)[1:3],0))\n            delta12@g   <- array(0,dim=c(dim(delta12@g)[1:3],0))\n            epsilon12@g <- array(0,dim=c(dim(epsilon12@g)[1:3],0))\n            \n            S <- list(alpha1=alpha1,delta1=delta1,epsilon1=epsilon1,\n                      alpha2=e1@alpha,delta2=e1@delta,epsilon2=e1@epsilon,\n                      delta12=delta12,epsilon12=epsilon12)\n\n            # make inverse\n            # S <- inverse(as.operator(e1))\n            # S <- symmOperator(alpha=S@alpha,\n            #                   delta=S@delta,\n            #                   epsilon=S@epsilon)\n\n            # initial energy\n          for (iter2 in 1:2) {\n            E <- E.symm.id(S)\n            dS <- dE.symm.id(S)\n            h <- dS\n            newS <- S\n#            cat(\"initiation: energy=\",E,\"\\n\")\n            # decrease energy\n            for (iter in 1:1000) {\n              # find derivative\n              #dS <- dE.symm.id(S,e1)\n              # decrease energy along gradient\n#              sq.dS <- sum(diag(integral(transpose(dS$alpha)*dS$alpha)+integral(transpose(dS$delta)*dS$delta)+integral(transpose(dS$epsilon)*dS$epsilon)))\n#              sq.dS <- sum(diag(integral(transpose(dS$delta)*dS$delta)+integral(transpose(dS$epsilon)*dS$epsilon)))\n#              sq.dS <- sum(diag(integral(transpose(h$delta1)*h$delta1)+integral(transpose(h$epsilon1)*h$epsilon1)+\n#                                integral(transpose(h$delta12)*h$delta12)+integral(transpose(h$epsilon12)*h$epsilon12)))\n#              lambda0 <- 4*2*E/sq.dS\n              lambda0 <- 128\n              \n              for (subs in 1:20) {\n                #newS@alpha <- S@alpha-lambda0*dS$alpha\n                newS$delta1@f    <- S$delta1@f-lambda0*h$delta1\n                newS$epsilon1@f  <- S$epsilon1@f-lambda0*h$epsilon1\n                newS$delta12@f   <- S$delta12@f-lambda0*h$delta12\n                newS$epsilon12@f <- S$epsilon12@f-lambda0*h$epsilon12\n                newE <- E.symm.id(newS)\n                if (newE<E) break\n                lambda0 <- lambda0/2\n              }\n              if (iter %% 1 == 0) cat(\"iteration\",iter,\": subdivisions=\",subs,\", lambda=\",lambda0,\": energy=\",newE)\n              #cat(\"\\n\")\n              # update\n              if (subs < 20) {\n                # conjugate gradient\n                dSnew <- dE.symm.id(newS)\n                gamma <- (sum((dSnew$delta1-0*dS$delta1)*dSnew$delta1) +\n                          sum((dSnew$epsilon1-0*dS$epsilon1)*dSnew$epsilon1) +\n                          sum((dSnew$delta12-0*dS$delta12)*dSnew$delta12) +\n                          sum((dSnew$epsilon12-0*dS$epsilon12)*dSnew$epsilon12)) /\n                  (sum(dS$delta1*dS$delta1)+sum(dS$epsilon1*dS$epsilon1)+\n                   sum(dS$delta12*dS$delta12)+sum(dS$epsilon12*dS$epsilon12))\n                gamma <- min(1,max(0,gamma))\n                cat(\", gamma=\",gamma,\"\\n\")\n                h$delta1    <- dSnew$delta1    + gamma*h$delta1\n                h$epsilon1  <- dSnew$epsilon1  + gamma*h$epsilon1\n                h$delta12   <- dSnew$delta12   + gamma*h$delta12\n                h$epsilon12 <- dSnew$epsilon12 + gamma*h$epsilon12\n                dS <- dSnew\n                E <- newE\n                S <- newS\n              } else break\n            }        \n          }\n            \n            tmp <- as.operator(symmOperator(alpha=S$alpha1,delta=S$delta1,epsilon=S$epsilon1))*as.operator(e1)\n            #plot(tmp@alpha)\n            plot(tmp@delta*transpose(tmp@epsilon))\n            plot(tmp@delta)\n            plot(tmp@epsilon)\n            \n            dS <- dE.symm.id(S)\n            profE <- rep(0,21)\n            lambda <- seq(-2*lambda0,2*lambda0,length.out=21)\n            for (i in 1:21) {\n            #  newS@alpha <- S@alpha+lambda[i]*dS@alpha\n              newS$delta1@f    <- S$delta1@f+lambda[i]*dS$delta1\n              newS$epsilon1@f  <- S$epsilon1@f+lambda[i]*dS$epsilon1\n              newS$delta12@f   <- S$delta12@f+lambda[i]*dS$delta12\n              newS$epsilon12@f <- S$epsilon12@f+lambda[i]*dS$epsilon12\n              profE[i] <- E.symm.id(newS)\n            }\n            par(mfrow=c(1,1))\n            plot(lambda,profE)\n            \n          })\n",
    "created" : 1410461985408.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1197914010",
    "id" : "CBF35971",
    "lastKnownWriteTime" : 1410895920,
    "path" : "C:/Users/pdq668/Dropbox/Full-rank functional regression/operatorCalc/R/symmOperator.R",
    "project_path" : "R/symmOperator.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}