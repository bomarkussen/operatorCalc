{
    "contents" : "# methods for standard generic functions: show,+,-,*,plot,[\n# methods for added generic functions:\nsetGeneric(\"evaluate\", function(x, e1, ...) standardGeneric(\"evaluate\"))\nsetGeneric(\"superSample\", function(x, e1, ...) standardGeneric(\"superSample\"))\nsetGeneric(\"forward\", function(e1, ...) standardGeneric(\"forward\"))\nsetGeneric(\"backward\", function(e1, ...) standardGeneric(\"backward\"))\nsetGeneric(\"integral\", function(e1, ...) standardGeneric(\"integral\"))\nsetGeneric(\"triangular\", function(e1, ...) standardGeneric(\"triangular\"))\nsetGeneric(\"transpose\", function(e1, ...) standardGeneric(\"transpose\"))\nsetGeneric(\"inverse\", function(e1, e2, ...) standardGeneric(\"inverse\"))\n\n# ------------------\n# Global options\n# ------------------\n\n.onLoad <- function(libname, pkgname) {\n  options(\"minimal.polynomial.order\"=2)\n  options(\"maximal.polynomial.order\"=8)\n}\n\n.onAttach <- function(libname, pkgname) {\n  options(\"minimal.polynomial.order\"=2)\n  options(\"maximal.polynomial.order\"=8)\n}\n\n# ------------------\n# Class definition\n# ------------------\n\nmatFct <- setClass(\"matFct\", slots=c(mesh=\"mesh\",f=\"array\",g=\"array\",continuous=\"logical\"))\n\nsetValidity(\"matFct\", function(object) {\n  msg <- NULL\n  valid <- TRUE\n  if (length(dim(object@f))!=3) {\n    valid <- FALSE\n    msg <- c(msg,\"Slot f must be a 3-way array\")\n  }\n  if (length(dim(object@g))!=4) {\n    valid <- FALSE\n    msg <- c(msg,\"Slot g must be a 4-way array\")\n  }\n  if (dim(object@f)[3]!=length(object@mesh)) {\n    valid <- FALSE\n    msg <- c(msg,\"Number of sampling points in f must equal mesh size\")\n  }\n  if (dim(object@g)[3]!=length(object@mesh)-1) {\n    valid <- FALSE\n    msg <- c(msg,\"Number of sampling points in g must equal mesh size - 1\")\n  }\n  if (any(dim(object@f)[1:2]!=dim(object@g)[1:2])) {\n    valid <- FALSE\n    msg <- c(msg,\"First two dimensions of f and g must be equal\")\n  }\n  if (length(object@continuous)!=dim(object@g)[3]) {\n    valid <- FALSE\n    msg <- c(msg,\"Length of continuity attribute must equal mesh size - 1\")\n  }\n  \n  if (valid) TRUE else msg\n})\n\n# ---------\n# Methods\n# ---------\n\nsetMethod(\"show\",\n          signature=\"matFct\",\n          definition=function(object) {\n            cat(\"An object of class \",class(object),\"\\n\",sep=\"\")\n            cat(\" Piecewise polynominal (order=\",max(1,dim(object@g)[4]),\") function: [\",\n                object@mesh[1],\",\",object@mesh[length(object@mesh)],\"] -> \",\n                paste(dim(object@f)[1:2],collapse=\"x\"),\" matrices\\n\",sep=\"\")\n            if (all(object@continuous)) {\n              cat(\" Supposed to be continuous in approximate computations\\n\") \n            } else {\n              cat(\" Supposed to be discontinuous at \",sum(!object@continuous),\" mesh points in approximate computations\\n\",sep=\"\")\n            }\n            invisible(NULL)\n          })\n\nsetMethod(\"[\",\n          signature=c(x=\"matFct\",i=\"numeric\",j=\"numeric\"),\n          definition=function(x,i,j) {\n            matFct(mesh=x@mesh,f=x@f[i,j,,drop=FALSE],g=x@g[i,j,,,drop=FALSE],continuous=x@continuous)\n          })\n\nsetMethod(\"plot\",\n          signature=c(x=\"numeric\",y=\"matFct\"),\n          definition=function(x,y) {\n            # evaluate function\n            x <- sort(unique(c(pmax(min(x),pmin(max(x),y@mesh)),x)))\n            yy <- evaluate(x,y)\n            # make plot\n            par(mfrow=dim(y@f)[1:2])\n            for (n in 1:dim(y@f)[1]) for (m in 1:dim(y@f)[2]) {\n              plot(x,yy[n,m,],type=\"n\",xlab=\"time\",ylab=paste(c(\"f[\",n,\",\",m,\"]\"),collapse=\"\"))\n              ii <- 1\n              for (jj in grep(FALSE,c(y@continuous[-length(y@continuous)],FALSE))) {\n                kk <- match(y@mesh[jj+1],x)\n                if (is.na(kk)) kk <- length(x)\n                points(x[ii],yy[n,m,ii],pch=16)\n                lines(x[ii:(kk-1)],yy[n,m,ii:(kk-1)])\n                ii <- kk\n                if (kk==length(x)) break\n              }\n            }\n          })\n\nsetMethod(\"plot\",\n          signature=c(x=\"matFct\",y=\"missing\"),\n          definition=function(x) {\n            plot(seq(x@mesh[1],x@mesh[length(x@mesh)],length.out=200),x)            \n          })\n\nsetMethod(\"evaluate\",\n          signature=c(x=\"numeric\",e1=\"matFct\"),\n          definition=function(x,e1) {\n            if (prod(dim(e1@f)[1:2])==0) {\n              # trivial result\n              return(array(0,dim=c(dim(e1@f)[1:2],length(x))))\n            } else {\n              # non-trivial result\n              x <- pmin(pmax(x,e1@mesh[1]),e1@mesh[length(e1@mesh)])\n              j <- findInterval(x,e1@mesh,rightmost.closed=TRUE)\n              s <- (x-e1@mesh[j])/(e1@mesh[j+1]-e1@mesh[j])\n              # call Rcpp\n              return(.Call('operatorCalc_evaluate', PACKAGE = 'operatorCalc', j-1, s, e1@f, e1@g))\n            }\n          })\n\nsetMethod(\"superSample\",\n          signature=c(x=\"numeric\",e1=\"matFct\"),\n          definition=function(x,e1) {\n            # is the function extended to the left?\n            left <- NULL\n            if (min(x) < min(e1@mesh)) {\n              left <- min(x)\n              x <- x[x >= min(e1@mesh)]\n            }\n            # is the function extended to the right?\n            right <- NULL\n            if (max(x) > max(e1@mesh)) {\n              right <- max(x)\n              x <- x[x <= max(e1@mesh)]\n            }\n            # take dimensions\n            N <- dim(e1@f)[1]\n            M <- dim(e1@f)[2]\n            r <- dim(e1@g)[4]\n            x <- sort(union(x,e1@mesh))\n            p <- length(x)\n            if ((N==0) || (M==0)) {\n              # trivial result\n              x <- c(left,x,right)\n              p <- length(x)\n              return(matFct(mesh=mesh(x),f=array(0,dim=c(N,M,p)),\n                            g=array(0,dim=c(N,M,p-1,0)),continuous=rep(TRUE,p-1)))\n            } else {\n              # non-trivial result\n              # construct the super sampled function inside the old range\n              j <- findInterval(x[-p],e1@mesh,rightmost.closed=TRUE)\n              a <- (x[-p]-e1@mesh[j])/(e1@mesh[j+1]-e1@mesh[j])\n              b <- (x[-1]-x[-p])/(e1@mesh[j+1]-e1@mesh[j])\n              res <- .Call('operatorCalc_superSample', PACKAGE = 'operatorCalc', outer(1:r,1:r,choose), j-1, a, b, e1@f, e1@g)\n              f <- res$f\n              g <- array(res$g,dim=c(N,M,p-1,r))\n              # construct continuity property\n              continuous <- rep(TRUE,p-1)\n              continuous[is.element(x[-1],e1@mesh)] <- e1@continuous\n              # extend the function to the left if necessary\n              if (!is.null(left)) {\n                x <- c(left,x)\n                f <- array(c(f[,,1],f),dim=c(N,M,p+1))\n                g <- aperm(array(c(rep(0,N*M*r),aperm(g,c(1,2,4,3))),dim=c(N,M,r,p)),c(1,2,4,3))\n                continuous <- c(TRUE,continuous)\n                p <- p+1\n              }\n              # extend the function to the right if necessary\n              if (!is.null(right)) {\n                x <- c(x,right)\n                f <- array(c(f,f[,,p]),dim=c(N,M,p+1))\n                g <- aperm(array(c(aperm(g,c(1,2,4,3)),rep(0,N*M*r)),dim=c(N,M,r,p)),c(1,2,4,3))\n                continuous <- c(continuous,TRUE)\n                p <- p+1\n              }\n              # return result\n              return(matFct(mesh=mesh(x),f=f,g=g,continuous=continuous))\n            }\n          })\n\nsetMethod(\"-\",\n          signature=c(e1=\"matFct\"),\n          definition=function(e1) {\n            matFct(mesh=e1@mesh,f=-e1@f,g=-e1@g,continuous=e1@continuous)\n          })\n\nsetMethod(\"+\",\n          signature=c(e1=\"matFct\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            # sanity check\n            if (any(dim(e1@f)[1:2]!=dim(e2@f)[1:2])) \n              stop(paste(\"Mismatch of dimensions (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") and (\",dim(e2@f)[1],\",\",dim(e2@f)[2],\") in matrix sum\",sep=\"\"))\n            # if e1 and e2 have different meshes then super sample both functions\n            if (!setequal(e1@mesh,e2@mesh)) {\n              e1 <- superSample(e2@mesh,e1)\n              e2 <- superSample(e1@mesh,e2)\n            }\n            # find g function\n            if (dim(e1@g)[4]==dim(e2@g)[4]) g <- e1@g+e2@g else {\n              if (dim(e1@g)[4]<dim(e2@g)[4]) {\n                q <- dim(e1@g)[4]\n                g <- e2@g\n                if (q>0) g[,,,1:q] <- g[,,,1:q,drop=FALSE]+e1@g\n              } else {\n                q <- dim(e2@g)[4]\n                g <- e1@g\n                if (q>0) g[,,,1:q] <- g[,,,1:q,drop=FALSE]+e2@g\n              }\n            }\n            # return result\n            matFct(mesh=e1@mesh,f=e1@f+e2@f,g=g,continuous=e1@continuous&e2@continuous)\n          })\n\nsetMethod(\"-\",\n          signature=c(e1=\"matFct\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            # sanity check\n            if (any(dim(e1@f)[1:2]!=dim(e2@f)[1:2])) \n              stop(paste(\"Mismatch of dimensions (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") and (\",dim(e2@f)[1],\",\",dim(e2@f)[2],\") in matrix differece\",sep=\"\"))\n            # if e1 and e2 have different meshes then super sample both functions\n            if (!setequal(e1@mesh,e2@mesh)) {\n              e1 <- superSample(e2@mesh,e1)\n              e2 <- superSample(e1@mesh,e2)\n            }\n            # find g function\n            if (dim(e1@g)[4]==dim(e2@g)[4]) g <- e1@g-e2@g else {\n              if (dim(e1@g)[4]<dim(e2@g)[4]) {\n                q <- dim(e1@g)[4]\n                g <- -e2@g\n                if (q>0) g[,,,1:q] <- g[,,,1:q,drop=FALSE]+e1@g\n              } else {\n                q <- dim(e2@g)[4]\n                g <- e1@g\n                if (q>0) g[,,,1:q] <- g[,,,1:q,drop=FALSE]-e2@g\n              }\n            }\n            # return result\n            matFct(mesh=e1@mesh,f=e1@f-e2@f,g=g,continuous=e1@continuous&e2@continuous)\n          })\n\nsetMethod(\"|\",\n          signature=c(e1=\"matFct\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            # sanity check\n            if (dim(e1@f)[1]!=dim(e2@f)[1])\n              stop(paste(\"Mismatch of dimensions (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") and (\",dim(e2@f)[1],\",\",dim(e2@f)[2],\") in column concatenation\",sep=\"\"))\n            # if e1 and e2 have different meshes then super sample both functions\n            if (!setequal(e1@mesh,e2@mesh)) {\n              e1 <- superSample(e2@mesh,e1)\n              e2 <- superSample(e1@mesh,e2)\n            }\n            # find f function\n            N  <- dim(e1@f)[1]\n            M1 <- dim(e1@f)[2]\n            M2 <- dim(e2@f)[2]\n            p  <- dim(e1@f)[3]\n            f  <- aperm(array(c(aperm(e1@f,c(1,3,2)),\n                                aperm(e2@f,c(1,3,2))),\n                              dim=c(N,p,M1+M2)),c(1,3,2))\n            # find g function\n            r1 <- dim(e1@g)[4]\n            r2 <- dim(e2@g)[4]\n            if (r1==r2) {\n              # e1 and e2 have same r\n              g <- aperm(array(c(aperm(e1@g,c(1,3,4,2)),\n                                 aperm(e2@g,c(1,3,4,2))),\n                               dim=c(N,p-1,r1,M1+M2)),c(1,4,2,3))\n            } else {\n              if (r1>r2) {\n                # zero pad forth dimension of e2@g to match that of e1@g\n                g <- aperm(array(c(aperm(e1@g,c(1,3,4,2)),\n                                   aperm(array(c(e2@g,rep(0,N*M2*(p-1)*(r1-r2))),dim=c(N,M2,p-1,r1)),c(1,3,4,2))),\n                                   dim=c(N,p-1,r1,M1+M2)),c(1,4,2,3))\n              } else {\n                # zero pad forth dimension of e1@g to match that of e2@g\n                g <- aperm(array(c(aperm(array(c(e1@g,rep(0,N*M1*(p-1)*(r2-r1))),dim=c(N,M1,p-1,r2)),c(1,3,4,2)),\n                                   aperm(e2@g,c(1,3,4,2))),\n                                 dim=c(N,p-1,r2,M1+M2)),c(1,4,2,3))\n              }\n            }\n            # return result\n            matFct(mesh=e1@mesh,f=f,g=g,continuous=e1@continuous&e2@continuous)\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"matFct\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            # sanity check\n            if (dim(e1@f)[2]!=dim(e2@f)[1]) \n              stop(paste(\"Mismatch of dimensions (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") and (\",dim(e2@f)[1],\",\",dim(e2@f)[2],\") in matrix product\",sep=\"\"))\n            # if e1 and e2 have different meshes then super sample both functions\n            if (!setequal(e1@mesh,e2@mesh)) {\n              e1 <- superSample(e2@mesh,e1)\n              e2 <- superSample(e1@mesh,e2)\n            }\n            # take dimensions\n            N <- dim(e1@f)[1]\n            M <- dim(e2@f)[2]\n            p <- length(e1@mesh)\n            if ((dim(e1@f)[2]==0) || (N==0) || (M==0)) {\n              # trivial answer due to empty inner sum or empty marginals\n              return(matFct(mesh=e1@mesh,f=array(0,dim=c(N,M,p)),g=array(0,dim=c(N,M,p-1,0)),\n                            continuous=rep(TRUE,p-1)))\n\n            } else {\n              # non-trivial answer\n              # Call C function to find (f,g)\n              res <- .Call('operatorCalc_multFct', PACKAGE = 'operatorCalc', e1@f, e1@g, e2@f, e2@g)\n              attr(res$g,\"dim\") <- c(N,M,p-1,max(1,dim(e1@g)[4])+max(1,dim(e2@g)[4]))\n              return(matFct(mesh=e1@mesh,f=res$f,g=res$g,continuous=e1@continuous&e2@continuous))\n            }\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"matrix\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            # sanity check\n            if (dim(e1)[2]!=dim(e2@f)[1])\n              stop(paste(\"Mismatch of dimensions (\",dim(e1)[1],\",\",dim(e1)[2],\") and (\",dim(e2@f)[1],\",\",dim(e2@f)[2],\") in matrix sum\",sep=\"\"))\n            # take dimensions\n            N <- dim(e1)[1]\n            M <- dim(e2@f)[2]\n            p <- length(e2@mesh)\n            if ((dim(e1)[2]==0) || (N==0) || (M==0)) {\n              # trivial answer due to empty inner sum or empty marginals\n              return(matFct(mesh=e2@mesh,f=array(0,dim=c(N,M,p)),g=array(0,dim=c(N,M,p-1,0)),\n                            continuous=rep(TRUE,p-1)))\n              \n            } else {\n              # non-trivial answer\n              # Call C function to find (f,g) and return result\n              res <- .Call('operatorCalc_multFct_left', PACKAGE = 'operatorCalc', e1, e2@f, e2@g)\n              attr(res$g,\"dim\") <- c(N,M,p-1,dim(e2@g)[4])\n              return(matFct(mesh=e2@mesh,f=res$f,g=res$g,continuous=e2@continuous))\n            }\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"matFct\",e2=\"matrix\"),\n          definition=function(e1,e2) {\n            # sanity check\n            if (dim(e1@f)[2]!=dim(e2)[1])\n              stop(paste(\"Mismatch of dimensions (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") and (\",dim(e2)[1],\",\",dim(e2)[2],\") in matrix sum\",sep=\"\"))\n            # take dimensions\n            N <- dim(e1@f)[1]\n            M <- dim(e2)[2]\n            p <- length(e1@mesh)\n            if ((dim(e2)[1]==0) || (N==0) || (M==0)) {\n              # trivial answer due to empty inner sum or empty marginals\n              return(matFct(mesh=e1@mesh,f=array(0,dim=c(N,M,p)),g=array(0,dim=c(N,M,p-1,0)),\n                            continuous=rep(TRUE,p-1)))\n            } else {\n              # non-trivial answer\n              # Call C function to find (f,g) and return result\n              res <- .Call('operatorCalc_multFct_right', PACKAGE = 'operatorCalc', e1@f, e1@g, e2)\n              attr(res$g,\"dim\") <- c(N,M,p-1,dim(e1@g)[4])\n              return(matFct(mesh=e1@mesh,f=res$f,g=res$g,continuous=e1@continuous))\n            }\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"numeric\",e2=\"matFct\"),\n          definition=function(e1,e2) {\n            matFct(mesh=e2@mesh,f=e1*(e2@f),g=e1*(e2@g),continuous=e2@continuous)\n          })\n\nsetMethod(\"*\",\n          signature=c(e1=\"matFct\",e2=\"numeric\"),\n          definition=function(e1,e2) {\n            matFct(mesh=e1@mesh,f=(e1@f)*e2,g=(e1@g)*e2,continuous=e1@continuous)\n          })\n\nsetMethod(\"forward\",\n          signature=c(e1=\"matFct\"),\n          definition=function(e1) {\n            if (prod(dim(e1@f)[1:2])==0) {\n              # trivial result\n              return(matFct(mesh=e1@mesh,\n                            f=array(0,dim=dim(e1@f)),\n                            g=array(0,dim=c(dim(e1@g)[1:3],0)),\n                            continuous=rep(TRUE,dim(e1@g)[3])))\n            } else {\n              # non-trivial result\n              # call Rcpp and return result\n              res <- .Call('operatorCalc_forward', PACKAGE = 'operatorCalc', diff(unclass(e1@mesh)), e1@f, e1@g)\n              attr(res$g,\"dim\") <- c(dim(e1@g)[1:3],max(1,dim(e1@g)[4])+1)\n              return(matFct(mesh=e1@mesh,f=res$f,g=res$g,continuous=rep(TRUE,dim(e1@g)[3])))\n            }\n          })\n\nsetMethod(\"backward\",\n          signature=c(e1=\"matFct\"),\n          definition=function(e1) {\n            if (prod(dim(e1@f)[1:2])==0) {\n              # trivial result\n              return(matFct(mesh=e1@mesh,\n                            f=array(0,dim=dim(e1@f)),\n                            g=array(0,dim=c(dim(e1@g)[1:3],0)),\n                            continuous=rep(TRUE,dim(e1@g)[3])))\n            } else {\n              # non-trivial result\n              # call Rcpp and return result\n              res <- .Call('operatorCalc_backward', PACKAGE = 'operatorCalc', diff(unclass(e1@mesh)), e1@f, e1@g)\n              attr(res$g,\"dim\") <- c(dim(e1@g)[1:3],max(1,dim(e1@g)[4])+1)\n              return(matFct(mesh=e1@mesh,f=res$f,g=res$g,continuous=rep(TRUE,dim(e1@g)[3])))\n            }\n          })\n\nsetMethod(\"integral\",\n          signature=c(e1=\"matFct\"),\n          definition=function(e1) {\n            # call Rcpp and return result\n            .Call('operatorCalc_integral', PACKAGE = 'operatorCalc', diff(unclass(e1@mesh)), e1@f, e1@g)\n          })\n\nsetMethod(\"triangular\",\n          signature=c(e1=\"matFct\"),\n          definition=function(e1) {\n            if (prod(dim(e1@f)[1:2])==0) {\n              # trivial result\n              return(f=array(0,dim=dim(e1@f)[1:3]))\n            } else {\n              # non-trivial result\n              # call Rcpp and return result\n              return(.Call('operatorCalc_triangular', PACKAGE = 'operatorCalc', diff(unclass(e1@mesh)), e1@f, e1@g))\n            }\n          })\n\nsetMethod(\"transpose\",\n          signature=c(e1=\"matFct\"),\n          definition=function(e1) {\n            matFct(mesh=e1@mesh,f=aperm(e1@f,c(2,1,3)),g=aperm(e1@g,c(2,1,3,4)),continuous=e1@continuous)\n          })\n\nsetMethod(\"inverse\",\n          signature=c(e1=\"matFct\",e2=\"missing\"),\n          definition=function(e1) {\n            # sanity check\n            if (dim(e1@f)[1]!=dim(e1@f)[2])\n              stop(paste(\"First argument of dimension (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") is non-square\",sep=\"\"))\n            # Take properties from matFct object and global options\n            order <- max(options()$\"minimal.polynomial.order\",min(options()$\"maximal.polynomial.order\",dim(e1@g)[4]))\n            ifelse(order>1, super <- 2*order+1, super <- 0)\n            continuous <- e1@continuous\n            # Call Cpp\n            res <- .Call('operatorCalc_inverse', PACKAGE = 'operatorCalc', e1@f, e1@g, order, super, continuous)\n            # fix Rcpp result: piecewise constant function?\n            if (order==0) {\n              res$g <- array(res$g[,1:dim(e1@g)[3]],dim=c(dim(e1@g)[1:2],1,dim(e1@g)[3]))\n              continuous <- c(rep(FALSE,dim(e1@g)[3]-1),TRUE)\n            }\n            # fix Rcpp result: piecewise linear function?\n            if (order==1) {\n              res$g <- array(0,dim=c(dim(e1@g)[1:2],0,dim(e1@g)[3]))\n              continuous <- rep(TRUE,dim(e1@g)[3])\n            }\n            # fix Rcpp result: piecewise polynomial function?\n            if (order>1) attr(res$g,\"dim\") <- c(dim(e1@g)[1:2],order,dim(e1@g)[3])\n            # return result\n            return(matFct(mesh=e1@mesh,f=res$f,g=aperm(res$g,c(1,2,4,3)),continuous=continuous))\n          })\n\nsetMethod(\"inverse\",\n          signature=c(e1=\"matFct\", e2=\"matFct\"),\n          definition=function(e1, e2) {\n            # sanity check\n            if (dim(e1@f)[1]!=dim(e1@f)[2])\n              stop(paste(\"First argument of dimension (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") is non-square\",sep=\"\"))\n            if (dim(e1@f)[2]!=dim(e2@f)[1])\n              stop(paste(\"Mismatch of dimensions (\",dim(e1@f)[1],\",\",dim(e1@f)[2],\") and (\",dim(e2@f)[1],\",\",dim(e2@f)[2],\") in linear equation\",sep=\"\"))\n            # Take properties from matFct object and global options\n            order <- max(options()$\"minimal.polynomial.order\",min(options()$\"maximal.polynomial.order\",dim(e1@g)[4]+dim(e2@g)[4]))\n            ifelse(order>1, super <- 2*order+1, super <- 0)\n            # if e1 and e2 have different meshes then super sample both functions\n            if (!setequal(e1@mesh,e2@mesh)) {\n              e1 <- superSample(e2@mesh,e1)\n              e2 <- superSample(e1@mesh,e2)\n            }\n            # pointwise solution of linear equation\n            res <- .Call('operatorCalc_solveFct', PACKAGE = 'operatorCalc', e1@f, e1@g, e2@f, e2@g, order, super, e1@continuous&e2@continuous)\n            attr(res$g,\"dim\") <- c(dim(e1@g)[1],dim(e2@g)[2],order,dim(e1@g)[3])\n            # return result\n            return(matFct(mesh=e1@mesh,f=res$f,g=aperm(res$g,c(1,2,4,3)),continuous=e1@continuous&e2@continuous))\n          })\n",
    "created" : 1410506951273.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2735570600",
    "id" : "4DDAA58F",
    "lastKnownWriteTime" : 1408971028,
    "path" : "C:/Users/pdq668/Dropbox/Full-rank functional regression/operatorCalc/R/matFct.R",
    "project_path" : "R/matFct.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}