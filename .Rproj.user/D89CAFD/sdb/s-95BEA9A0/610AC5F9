{
    "contents" : "#include <RcppArmadillo.h>\n#include <Rcpp.h>\n\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nSEXP inv_beta(NumericVector alpha_f, SEXP alpha_g, NumericVector beta_f, SEXP beta_g, NumericVector lambda, double order, double super, LogicalVector continuous) {\n  // Assume that dimensions match\n  // No sanity check performed!\n  // lambda is short for kappa.transpose\n  // Assume order>1 and super>0:\n\n  NumericVector vec_alpha(alpha_g);\n  NumericVector vec_beta(beta_g);\n  IntegerVector dims1 = vec_alpha.attr(\"dim\");\n  IntegerVector dims2 = vec_beta.attr(\"dim\");\n\n  int p = dims1[2];      // NB: 1 less in order to simplify code\n  int r1 = dims1[3];\n  int r2 = dims2[3];\n  \n  arma::cube fa(alpha_f.begin(), dims1[0], dims1[1], p+1, false);\n  arma::cube fb(beta_f.begin(),  dims2[0], dims2[1], p+1, false);\n  arma::cube fl(lambda.begin(),  dims2[1], dims2[1], p*(super+1)+1, false);\n  arma::cube fx(dims1[0], dims2[1], p+1);\n  arma::cube ga(vec_alpha.begin(), dims1[0], dims1[1], r1*p, false);\n  arma::cube gb(vec_beta.begin(),  dims2[0], dims2[1], r2*p, false);\n  arma::mat  gx(std::max(1.0,order)*p, dims1[0]*dims2[1]);\n  gx.fill(0.0);\n  arma::mat  tmp1(dims1[0], dims1[1]);\n  arma::mat  tmp2(dims2[0], dims2[1]);\n  \n  // find inverse at knot points\n  for (int j=0; j<p; j++) fx.slice(j) = -arma::solve(fa.slice(j),fb.slice(j)*fl.slice(j*(super+1)));\n  tmp1 = fa.slice(p);\n  tmp2 = fb.slice(p);\n  for (int k=0; k<r1; k++) tmp1 += ga.slice(p-1+k*p);\n  for (int k=0; k<r2; k++) tmp2 += gb.slice(p-1+k*p);\n  fx.slice(p) = -arma::solve(tmp1,tmp2*fl.slice(p*(super+1)));\n  \n  // Assume order>1 and super>0:\n  // make interpolation of inverse between knot points\n  // there are internal intervals points and an OLS to be solved\n  // set-up matrices\n  int q_cont = std::min(order-1,super);\n  int q_discont = std::min(order,super);\n  arma::vec s(super);\n  arma::mat A_cont(super,q_cont);\n  arma::mat A_discont(super,q_discont);\n  arma::mat B(super,dims1[0]*dims2[1]);\n  // precomputations\n  for (int k=0; k<super; k++) s.row(k) = (k+1)/(super+1);\n  for (int k=0; k<super; k++) for (int l=0; l<q_cont; l++) A_cont(k,l) = pow(s(k),l+2)-s(k);\n  for (int k=0; k<super; k++) for (int l=0; l<q_discont; l++) A_discont(k,l) = pow(s(k),l+1);\n  // loop over sampling intervals\n  for (int j=0; j<p; j++) {\n    // make interval data by removing linear interpolation\n    for (int k=0; k<super; k++) {\n      tmp1 = (1-s(k))*fa.slice(j) + s(k)*fa.slice(j+1);\n      tmp2 = (1-s(k))*fb.slice(j) + s(k)*fb.slice(j+1);\n      for (int l=0; l<r1; l++) tmp1 += pow(s(k),l+1)*ga.slice(j+l*p);\n      for (int l=0; l<r2; l++) tmp2 += pow(s(k),l+1)*gb.slice(j+l*p);\n      B.row(k) = arma::trans(arma::vectorise(-arma::solve(tmp1,tmp2*fl.slice(j*(super+1)+k))\n      -(1-s(k))*fx.slice(j)-s(k)*fx.slice(j+1)));\n    }\n    // make design matrix\n    if (continuous(j)) {\n      // enforce continuity in this interval\n      gx.rows(j*order+1,j*order+q_cont) = arma::solve(A_cont,B);\n      for (int k=1; k<=q_cont; k++) gx.row(j*order) -= gx.row(j*order+k);\n    } else {\n      // allow for discontinuity in this interval\n      gx.rows(j*order,j*order+q_discont-1) = arma::solve(A_discont,B);\n    }\n  }\n  \n  // return to R\n  return(List::create(Rcpp::Named(\"f\")=fx, Rcpp::Named(\"g\")=arma::trans(gx)));\n}\n",
    "created" : 1442925141456.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2531946861",
    "id" : "610AC5F9",
    "lastKnownWriteTime" : 1408966644,
    "path" : "C:/Users/pdq668/Dropbox/Full-rank functional regression/operatorCalc/src/inv_beta.cpp",
    "project_path" : "src/inv_beta.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "cpp"
}